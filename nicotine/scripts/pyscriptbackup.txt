#ifndef PARSETREE_CPP
#define PARSETREE_CPP

#include <vector>
#include <iostream>

#include "token.h"

enum class NodeType{
    statement,
    parentheses,
    function,
    operand,
    prefix_unary_op,
    postfix_unary_up,
    unary_uperator,
    binary_op,
    binary_operator,
    variable,
    value
};
//--- begin auto generated by python script ---
const std::string NodeTypeStrings[] = {"statement","parentheses","function","operand","prefix_unary_op","postfix_unary_up","unary_uperator","binary_op","variable","value",};
std::ostream& operator<<(std::ostream& out, NodeType t){ return out << NodeTypeStrings[(int)t]; }
//---  end auto generated by python script  ---

struct Node{
    NodeType type;
    Token token;
    std::vector<Node*> children = {};
    Node(NodeType _type) : type(_type) {}
    Node(NodeType _type, Token _token) : type(_type), token(_token) {}
    ~Node(){
        for(int i = 0; i < children.size(); i++){
            delete children.at(i);
        }
    }
};


//gets passed a stack which represents a target's possible definition, 
//tries to compute a valid tree from that
//if unsuccessful, returns {}
std::vector<Node*> parseTreeBacktracking(std::vector<Token> &tokens, std::vector<Token>::iterator it, std::vector<Node*> &stack){
    while(!stack.empty()){
        Node* target = stack.back();
        stack.pop_back();
        if(it == tokens.end()){
            std::cerr << "Error, expected: "; 
            std::cerr << target->type << "at eof\n";
            return {};
        }
        try{
            switch(target->type){
                case NodeType::statement:
                    break;
                
                case NodeType::value:
            }
        } catch(const std::out_of_range& oor){
            std::cerr << "Error, eof with unsatisfied parameters\n";
            std::cerr << "Trying to parse a " << target->type << "\n";
            return {};
        }
    }
//    return something;
}


std::vector<Node*> createParseTree(std::vector<Token> &tokens){
    std::vector<Node*> stack;
    stack.push_back(new Node(NodeType::statement));
    Node* head = stack.at(0);
    int linenumber = 1;

    std::vector<Token>::iterator it = tokens.begin();
    while(!stack.empty()){
        Node* target = stack.back();
    }
}

#endif