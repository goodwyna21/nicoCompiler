#ifndef TOKEN_H
#define TOKEN_H

#include <string>

enum class TokenType{
    INT_LITERAL,
    STR_LITERAL,
    IDENTIFIER,
    OPEN_PARENTH,
    CLOSE_PARENTH,
    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_CURLY,
    CLOSE_CURLY,
    COMMA,
    SEMI,
    NEWLINE,
    BINARY_OPERATOR,
    UNARY_OPERATOR,
    RESERVED,
    NULLTOKEN
};

enum class NodeType{
    statement,
    operand,
    variable,
    value,
    identifier,
    _operator,
};

enum class NodeSubType{
    func_call,
    _return,
    prefix_unary,
    postfix_unary,
    binary_op,
    array_access,
    none
};

enum class ErrorType{
    MAX_DEPTH,
    INVALID_ARGUMENT,
    EXPECTED_STATEMENT,
    UNEXPECTED_EOF,
    SYNTAX_ERROR,
    NONE,
};

//--- begin auto generated by python script ---
const std::string TokenTypeStrings[] = {
    "INT_LITERAL",
    "STR_LITERAL",
    "IDENTIFIER",
    "OPEN_PARENTH",
    "CLOSE_PARENTH",
    "OPEN_BRACKET",
    "CLOSE_BRACKET",
    "OPEN_CURLY",
    "CLOSE_CURLY",
    "COMMA",
    "SEMI",
    "NEWLINE",
    "BINARY_OPERATOR",
    "UNARY_OPERATOR",
    "RESERVED",
    "NULLTOKEN",
};
const std::string NodeTypeStrings[] = {
    "statement",
    "operand",
    "variable",
    "value",
    "identifier",
    "operator"
};
const std::string NodeSubTypeStrings[] = {
    "func_call",
    "return",
    "prefix_unary",
    "postfix_unary",
    "binary_op",
    "array_access",
    "none"
};
const std::string ErrorTypeStrings[] = {
    "MAX_DEPTH",
    "INVALID_ARGUMENT",
    "EXPECTED_STATEMENT",
    "UNEXPECTED_EOF",
    "SYNTAX_ERROR",
    "NONE",
};
//---  end auto generated by python script  ---

//extern std::ostream& operator<<(std::ostream& out, NodeType t);
//extern std::ostream& operator<<(std::ostream& out, TokenType t);
//extern std::ostream& operator<<(std::ostream& out, NodeSubType t);
//extern std::ostream& operator<<(std::ostream& out, ErrorType t);

inline std::ostream& operator<<(std::ostream& out, TokenType t){ return out << TokenTypeStrings[(int)t]; }
inline std::ostream& operator<<(std::ostream& out, NodeType t){ return out << NodeTypeStrings[(int)t]; }
inline std::ostream& operator<<(std::ostream& out, NodeSubType t){ return out << NodeSubTypeStrings[(int)t]; };
inline std::ostream& operator<<(std::ostream& out, ErrorType t){ return out << ErrorTypeStrings[(int)t]; }

struct Token{
    TokenType type;
    int i_value = 0;
    bool has_i_val = false;
    std::string s_value = "";
    bool has_s_val = false;
    int lineNumber = -1;
    Token() : type(TokenType::NULLTOKEN) {}
    Token(TokenType _type) : type(_type) {}
    Token(TokenType _type, int _value) : type(_type), i_value(_value), has_i_val(true) {}
    Token(TokenType _type, std::string _value) : type(_type), s_value(_value), has_s_val(true) {}
};

#endif